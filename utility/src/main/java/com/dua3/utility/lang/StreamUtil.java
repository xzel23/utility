package com.dua3.utility.lang;


import com.dua3.utility.data.PeekIterator;
import com.dua3.utility.io.IoUtil;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.function.BiFunction;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

/**
 * Utility class for Java streams.
 */
public final class StreamUtil {

    private StreamUtil() {
    }

    /**
     * Zip two streams, creating a new stream consisting of items generated by applying the given {@link BiFunction}
     * on items taken from the input streams.
     * <p>
     * Consider two streams {@code a = a1, a2, a3, ...} and {@code b = b1, b2, b3, ...}. The result of zipping
     * is a new stream {@code zip(a,b) = op(a1,b1), op(a2,b2), op(a3,b3) ...}.
     * <p>
     * The stream ends when either {@code a} or {@code b} end.
     *
     * @param a   first stream
     * @param b   second stream
     * @param op the operation that generates new items for the output stream
     * @param <A> first stream generic item type
     * @param <B> second stream generic item type
     * @param <C> result stream generic item type
     * @return stream consisting of pairs od items created from items of either stream
     */
    public static <A, B, C> Stream<C> zip(Stream<A> a, Stream<B> b, BiFunction<? super A, ? super B, ? extends C> op) {
        Iterator<A> i1 = a.iterator();
        Iterator<B> i2 = b.iterator();
        Iterable<C> i = () -> new Iterator<>() {
            @Override
            public boolean hasNext() {
                return i1.hasNext() && i2.hasNext();
            }

            @Override
            public C next() {
                return op.apply(i1.next(), i2.next());
            }
        };
        Stream<C> stream = StreamSupport.stream(i.spliterator(), false);
        return stream.onClose(IoUtil.composedClose(a, b));
    }

    /**
     * Concat multiple streams. The resulting stream contains all elements from the first passed stream followed
     * by the elements of the second passed stream, and so on.
     *
     * @param streams the streams to concat
     * @param <T>     the generic element type
     * @return the stream creating by concatenating elements from the argument streams
     */
    @SafeVarargs
    public static <T> Stream<T> concat(Stream<T>... streams) {
        return Stream.of(streams).flatMap(i -> i);
    }

    /**
     * Merge several <strong>sorted</strong> streams into a single sorted stream containing the elements from the
     * streams passed as the argument.
     *
     * @param comparator the comparator that defines the sort order
     * @param streams    the sorted streams to merge
     * @param <T>        the generic element type
     * @return sorted stream containing the elements of the argument streams
     */
    @SafeVarargs
    public static <T> Stream<T> merge(Comparator<? super T> comparator, Stream<T>... streams) {
        var iters = Arrays.stream(streams).map(Stream::iterator).toList();
        Iterable<T> i = () -> new MergeIterator<>(comparator, iters);
        Stream<T> stream = StreamSupport.stream(i.spliterator(), false);
        return stream.onClose(IoUtil.composedClose(streams));
    }

    /**
     * Merge several <strong>sorted</strong> streams into a single sorted stream containing the elements from the
     * streams passed as the argument. Natural sort order is used as implemented in the element class.
     *
     * @param streams the sorted streams to merge
     * @param <T>     the generic element type
     * @return sorted stream containing the elements of the argument streams
     */
    @SafeVarargs
    public static <T extends Comparable<T>> Stream<T> merge(Stream<T>... streams) {
        return merge(Comparator.naturalOrder(), streams);
    }

    /**
     * Create a stream from the elements obtained from an iterator.
     *
     * @param iter the iterator
     * @param <T>  the element type
     * @return stream of elements
     */
    public static <T> Stream<T> stream(Iterator<T> iter) {
        return stream(() -> iter);
    }

    /**
     * Create a stream from the elements obtained from an iterable.
     *
     * @param iterable the iterable
     * @param <T>      the element type
     * @return stream of elements
     */
    public static <T> Stream<T> stream(Iterable<T> iterable) {
        return StreamSupport.stream(iterable.spliterator(), false);
    }

    private static class MergeIterator<T> implements Iterator<T> {

        private final Comparator<? super T> comparator;
        private final List<PeekIterator<T>> iters = new ArrayList<>();

        MergeIterator(Comparator<? super T> comparator, Collection<Iterator<T>> iters) {
            this.comparator = comparator;
            iters.stream().map(PeekIterator::new).forEach(this.iters::add);
        }

        @Override
        public boolean hasNext() {
            return iters.stream().anyMatch(Iterator::hasNext);
        }

        @Override
        public T next() {
            //noinspection NewExceptionWithoutArguments
            return iters.stream().min(this::compareNextElement).orElseThrow(NoSuchElementException::new).next();
        }

        private int compareNextElement(PeekIterator<? extends T> i1, PeekIterator<? extends T> i2) {
            if (!i1.hasNext()) {
                return 1;
            }
            if (!i2.hasNext()) {
                return -1;
            }
            return comparator.compare(i1.peek(), i2.peek());
        }

    }

}
